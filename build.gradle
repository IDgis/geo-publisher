subprojects {
	apply plugin: 'java-base'
	
	repositories {
		jcenter()
		mavenCentral()
		maven {
			name "typesafe-maven-release"
			url "https://repo.typesafe.com/typesafe/maven-releases"
		}
		ivy {
			name "typesafe-ivy-release"
			url "https://repo.typesafe.com/typesafe/ivy-releases"
			layout "ivy"
		}
		maven {
			name "idgis-public"
			url "http://nexus.idgis.eu/content/groups/public/"
			credentials {
				username nexusUser 
				password nexusPassword
			}
		}
		maven {
			name "idgis-restricted"
			url "http://nexus.idgis.eu/content/groups/restricted/"
			credentials {
				username nexusUser 
				password nexusPassword
			}
		}
	}
}

def junitVersion = '4.11'
def scalaAbiVersion = '2.11'
def akkaVersion = '2.3.9'
def jacksonVersion = '2.3.3'
def guavaVersion = '17.0'
def h2Version = '1.4.180'
def jodatimeVersion = '2.3'
def querydslVersion = '3.4.1'
def geoserverVersion = '2.6.1-gpo-3'

project(':publisher-test') {
	apply plugin: 'java'

	dependencies {
		compile "com.typesafe.akka:akka-actor_${scalaAbiVersion}:${akkaVersion}"
		compile "junit:junit:${junitVersion}"
		compile 'org.mockito:mockito-core:1.10.19'
	}
}

project(':publisher-commons') {
	apply plugin: 'java'

	dependencies {
		testCompile project(':publisher-test')
		testCompile "com.typesafe.akka:akka-testkit_${scalaAbiVersion}:${akkaVersion}"
		testCompile "com.typesafe.akka:akka-slf4j_${scalaAbiVersion}:${akkaVersion}"
		testCompile 'ch.qos.logback:logback-classic:1.1.2'
		testCompile "com.h2database:h2:${h2Version}"
	
		compile "com.fasterxml.jackson.core:jackson-databind:${jacksonVersion}"
		compile "com.typesafe.akka:akka-actor_${scalaAbiVersion}:${akkaVersion}"
		compile 'org.apache.commons:commons-lang3:3.3.2'
		compile "com.google.guava:guava:${guavaVersion}"
		compile 'com.jolbox:bonecp:0.8.0.RELEASE'
		compile 'commons-io:commons-io:2.4'
		compile 'org.aspectj:aspectjrt:1.8.0'
		compile 'org.codehaus.woodstox:woodstox-core-lgpl:4.1.5'
	}
	
	def keystoreLocation = new File(sourceSets.test.output.resourcesDir, '/nl/idgis/publisher/protocol')
	
	def keystoreClient = new File(keystoreLocation, 'client.jks')
	def certClient = new File(keystoreLocation, 'client.cer')
	
	def keystoreServer = new File(keystoreLocation, 'server.jks')
	def certServer = new File(keystoreLocation, 'server.cer')
	
	def keystoreTrusted = new File(keystoreLocation, 'trusted.jks')
	
	def keyalg = 'RSA'
	def dname = 'cn=IDgis Developers, ou=None, L=Rijssen, ST=Overijssel, o=IDgis bv, c=NL'
	
	task prepareKeystoreLocation << {
		keystoreLocation.mkdirs()
		
		[keystoreClient, keystoreServer, keystoreTrusted].each {
			if(it.exists()) {
				it.delete()
			}
		}
	}
	
	task generateClientKey(type: Exec, dependsOn: prepareKeystoreLocation) {
		commandLine 'keytool', 
			'-genkeypair', 
			'-keyalg', keyalg, 
			'-dname', dname, 
			'-keystore', keystoreClient,
			'-storepass', 'client', 
			'-keypass', 'client', 
			'-alias', 'client'
	}
	
	task exportClientCert(type: Exec, dependsOn: generateClientKey) {
		commandLine 'keytool', 
			'-exportcert', 
			'-keystore', keystoreClient,
			'-storepass', 'client', 
			'-keypass', 'client', 
			'-alias', 'client',
			'-file', certClient,
			'-rfc'
	}
	
	task generateServerKey(type: Exec, dependsOn: prepareKeystoreLocation) {
		commandLine 'keytool', 
			'-genkeypair', 
			'-keyalg', keyalg, 
			'-dname', dname, 
			'-keystore', keystoreServer,
			'-storepass', 'server', 
			'-keypass', 'server', 
			'-alias', 'server'
	}
	
	task exportServerCert(type: Exec, dependsOn: generateServerKey) {
		commandLine 'keytool', 
			'-exportcert', 
			'-keystore', keystoreServer,
			'-storepass', 'server', 
			'-keypass', 'server', 
			'-alias', 'server',
			'-file', certServer,
			'-rfc'
	}
	
	task importClientCert(type: Exec, dependsOn: exportClientCert) {
		commandLine 'keytool', 
			'-importcert',
			'-keystore', keystoreTrusted,
			'-storepass', 'trusted',
			'-alias', 'client',
			'-file', certClient,
			'-noprompt'
	}
	
	task importServerCert(type: Exec, dependsOn: exportServerCert) {
		commandLine 'keytool', 
			'-importcert',
			'-keystore', keystoreTrusted,
			'-storepass', 'trusted',
			'-alias', 'server',
			'-file', certServer,
			'-noprompt'
	}
	
	processTestResources.dependsOn(importClientCert, importServerCert)
}

project(':publisher-domain') {
	apply plugin: 'java'

	dependencies {
		testCompile "junit:junit:${junitVersion}"
	
		compile project(':publisher-commons');
		compile "com.google.guava:guava:${guavaVersion}"
		compile "com.mysema.querydsl:querydsl-core:${querydslVersion}"
		compile "com.fasterxml.jackson.core:jackson-databind:${jacksonVersion}"
		compile "joda-time:joda-time:${jodatimeVersion}"
		compile "com.typesafe.akka:akka-actor_${scalaAbiVersion}:${akkaVersion}"
	}
}

project(':publisher-schemas') {
	apply plugin: 'java'

	configurations {
		schemas {
			transitive = false
		}
	}
	
	dependencies {
		testCompile "junit:junit:${junitVersion}"
		
		schemas "org.geoserver:gs-main:${geoserverVersion}"
	}
	
	task unpackSchemas << {
		configurations.schemas.resolvedConfiguration.resolvedArtifacts.each { artifact ->
			project.copy {
				from zipTree(artifact.file).matching {
					include 'schemas/**/*'
				}
				eachFile {
					it.path = it.path.replace('schemas/', 'schemas/geoserver/')
				}
				includeEmptyDirs = false
				into sourceSets.main.output.resourcesDir
			}
		}
	}
	
	processResources.dependsOn(unpackSchemas)
}

buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath "com.github.houbie:lesscss-gradle-plugin:1.0.3-less-1.7.0"
    }
}

import com.github.houbie.gradle.lesscss.LesscTask

project(':publisher-web') {
	apply plugin: 'play'
	
	configurations {
		compile
		testCompile
		play.extendsFrom(compile)
		playTest.extendsFrom(testCompile)
	}
	
	def playVersion = '2.3.4'
	
	model {
		components {
			play {
				platform play: playVersion, java: '1.8'
				
				binaries.all { binary ->
				
					def lessDestinationDir = "${project.buildDir}/less/"
					def extractLessTask = tasks.taskName('extract', 'less')
					
					binary.assets.addAssetDir project.file(lessDestinationDir)
					
					tasks.create(extractLessTask, Copy) { task ->
						from {
							project.configurations.play.collect { 
								project.zipTree(it).matching { include 'META-INF/resources/webjars/**' }
							}
						}
						into lessDestinationDir + "lib/"
						eachFile { details ->
							def shortPath = (details.path - "META-INF/resources/webjars/")
							def parts = shortPath.split '/'
							def result = new StringBuilder ()
							for(int i = 0; i < parts.length; ++ i) {
								if(i == 1) {
									continue;
								}
								if(result.length () > 0) {
									result.append "/"
								}
								result.append parts[i]
							}
							def targetPath = result.toString ()
							details.path = targetPath
						}
						
						binary.assets.builtBy task
					}
					
					project.tasks.create(tasks.taskName('compile', 'less'), LesscTask) { task ->
						sourceDir 'app/assets', lessDestinationDir
						include '**/*.less'
						exclude '**/_*.less'
						exclude 'lib/**'
						destinationDir = project.file("${project.buildDir}/${binary.name}/lessAssets")

						binary.assets.addAssetDir destinationDir
						binary.assets.builtBy task
						dependsOn extractLessTask
					}
				
					def fixTask = project.tasks.create(tasks.taskName('fix', 'twirlTemplates'))
					
					fixTask << {
						binary.generatedScala.each { generated ->
							if(generated.key.name == 'twirlTemplates') {
								generated.value.source.visit { item ->
									if(!item.isDirectory()) {
										def sourceLines = item.file.readLines();
										
										sourceLines.remove(6);
										
										['import play.api.templates.PlayMagic._',
										'import models._',
										'import controllers._',
										'import java.lang._',
										'import java.util._',
										'import scala.collection.JavaConversions._',
										'import scala.collection.JavaConverters._',
										'import play.api.i18n._',
										'import play.core.j.PlayMagicForJava._',
										'import play.mvc._',
										'import play.data._',
										'import play.api.data.Field',
										'import play.mvc.Http.Context.Implicit._',
										'import views.html._'].eachWithIndex { line, lineNo ->
											sourceLines.add(6 + lineNo, line)
										}
										
										item.file.write(sourceLines.join('\n'))
									}
								}
							}
						}
					}
				
					tasks.whenObjectAdded { task ->
						if(task.name == tasks.taskName('compile', 'twirlTemplates')) {
							fixTask.dependsOn(task)
						}
						
						if(task.name == tasks.taskName('compile', 'scala')) {
							task.dependsOn(fixTask)
						}
					}
				}
			}
		}
	}
	
	dependencies {
		play project(':publisher-domain')
		play project(':publisher-schemas')
		play "com.typesafe.play:play-java-jdbc_${scalaAbiVersion}:${playVersion}"
		play "com.typesafe.play:play-cache_${scalaAbiVersion}:${playVersion}"
		play "com.typesafe.play:play-java-ws_${scalaAbiVersion}:${playVersion}"
		play "org.webjars:webjars-play_${scalaAbiVersion}:2.3.0"
		play 'org.webjars:bootstrap:3.2.0'
  		play 'org.webjars:dojo:1.10.0'
  		play "com.typesafe.akka:akka-remote_${scalaAbiVersion}:${akkaVersion}"
  		play 'org.pegdown:pegdown:1.5.0'
		play('org.apache.zookeeper:zookeeper:3.4.5') {
			exclude group: 'javax.jms', module: 'jms'
			exclude group: 'com.sun.jdmk', module: 'jmxtools'
			exclude group: 'com.sun.jmx', module: 'jmxri'
			exclude group: 'org.jboss.netty', module: 'netty'
		}
  		play 'org.webjars:ace:01.08.2014'
	}
}

gradle.addListener(new TimingListener())